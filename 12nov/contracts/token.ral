import "std/fungible_token_interface"


Contract Token (
    supply: U256,
    decimals: U256,
    name: ByteVec,
    symbol: ByteVec,
    mut balance : U256
) implements IFungibleToken {

    event Withdraw(to: Address, amount: U256)

    enum ErrorCodes {
        InvalidWithdrawAmount = 0
    }
    
    pub fn getTotalSupply() -> U256 {
        return supply
    }

    pub fn getDecimals() -> U256 {
        return decimals
    }

    pub fn getName() -> ByteVec {
        return name
    }

    pub fn getSymbol() -> ByteVec {
        return symbol
    }

    pub fn balance() -> U256 {
        return balance
    }

    // A public function that transfers tokens to anyone who calls it.
    // The function is annotated with `updateFields = true` as it changes the contract fields.
    // The function is annotated as using contract assets as it does.
    // The function is annotated with `checkExternalCaller = false` as there is no need to check the external caller.
    @using(assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn withdraw(amount: U256) -> () {
        // Debug events can be helpful for error analysis
        emit Debug(`The current balance is ${balance}`)

        // Make sure the amount is valid
        assert!(amount <= 2, ErrorCodes.InvalidWithdrawAmount)
        // Functions postfixed with `!` are built-in functions.
        transferTokenFromSelf!(callerAddress!(), selfTokenId!(), amount)
        // Ralph does not allow underflow.
        balance = balance - amount

        // Emit the event defined earlier.
        emit Withdraw(callerAddress!(), amount)
    }

}